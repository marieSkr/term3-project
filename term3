from PIL import Image
import math

# PART X================


def matrix_addition(a, b):
    for i in range(len(a)):  # checking if a is a matrix
        if len(a[i]) != len(a[0]):
            print('a not a matrix')
            return None
    for i in range(len(b)):  # checking if b is a matrix
        if len(b[i]) != len(b[0]):
            print('b not a matrix')
            return None
    if len(a) != len(b):  # checking if the amount of rows is equal
        print(f'a has {len(a)} rows and b has {len(b)} rows. incorrect')
        return None
    if len(a[0]) != len(b[0]):  # checking if the amount of columns is equal
        print(f'a has {len(a[0])} columns and b has {len(b[0])} columns. incorrect')
        return None

    c = []

    for i in range(len(a)):
        row = []
        for j in range(len(a[0])):
            row.append(a[i][j] + b[i][j])
        c.append(row)
    return c


def matrix_subtraction(a, b):
    for i in range(len(a)):  # checking if a is a matrix
        if len(a[i]) != len(a[0]):
            print('a is not a matrix')
            return None
    for i in range(len(b)):  # checking if b is a matrix
        if len(b[i]) != len(b[0]):
            print('b is not a matrix')
            return None
    if len(a) != len(b):  # checking if the amount of rows is equal
        print(f'a has {len(a)} rows and b has {len(b)} rows. incorrect')
        return None
    if len(a[0]) != len(b[0]):  # checking if the amount of columns is equal
        print(f'a has {len(a[0])} columns and b has {len(b[0])} columns. incorrect')
        return None

    c = []

    for i in range(len(a)):
        c1 = []
        for j in range(len(a[0])):
            c1.append(a[i][j] - b[i][j])
        c.append(c1)
    return c


def matrix_multiplication(a, b):
    for i in range(len(a)):  # checking if a is a matrix
        if len(a[i]) != len(a[0]):
            print('a is not a matrix')
            return None
    for i in range(len(b)):  # checking if b is a matrix
        if len(b[i]) != len(b[0]):
            print('b is not a matrix')
            return None
    if len(a[0]) != len(b):  # checking if the amount of columns of a is equal to the amount of rows of b
        print(f'a has {len(a[0])} columns and b has {len(b)} rows. incorrect')
        return None

    c = []
    for i in range(len(a)):
        row = []
        for j in range(len(b[0])):
            ab = 0
            for k in range(len(a[0])):
                ab += a[i][k] * b[k][j]
            row.append(ab)
        c.append(row)
    return c


def matrix_transpose(a):
    for i in range(len(a)):  # checking if a is a matrix
        if len(a[i]) != len(a[0]):
            print('a not a matrix')
            return None
    c = []
    for i in range(len(a[0])):
        row = []
        for j in range(len(a)):
            row.append(a[j][i])
        c.append(row)

    return c


def scalar_multiplication(a, scalar):
    for i in range(len(a)):  # checking if a is a matrix
        if len(a[i]) != len(a[0]):
            print('a not a matrix')
            return None
    c = []
    for i in range(len(a)):
        row = []
        for j in range(len(a[0])):
            row.append(a[i][j] * scalar)
        c.append(row)

    return c


# PART Y ================


def image_to_matrix(img):
    width, height = img.size
    matrix = []
    for y in range(height):
        row = []
        for x in range(width):
            row.append(img.getpixel((x, y)))
        matrix.append(row)

    return matrix


def matrix_to_image(matrix):
    height = len(matrix)
    width = len(matrix[0])
    img = Image.new("RGBA", (width, height))

    for y in range(height):
        for x in range(width):
            img.putpixel((x, y), matrix[y][x])
    return img


def rotate_matrix(matrix, angle_degrees):
    height = len(matrix)
    width = len(matrix[0])
    angle = math.pi * angle_degrees / 180  # turn degrees into radians

    # height is negative to switch to Cartesian coords (y-up) instead of image coords (y-down)
    corners = [[0, 0], [width, 0], [width, -height], [0, -height]]

    for a in corners:
        a0 = a[0]
        a1 = a[1]
        a[0] = int(a0 * math.cos(angle) - a1 * math.sin(angle)) #formula for rotating a vector need a source for this
        a[1] = int(a0 * math.sin(angle) + a1 * math.cos(angle))

    offset_y = max(corners, key=lambda v: v[1])[1] # explain in methodology
    offset_x = -min(corners, key=lambda v: v[0])[0]
    width2 = offset_x + max(corners, key=lambda v: v[0])[0]
    height2 = offset_y - min(corners, key=lambda v: v[1])[1]

    offset_x_rotated = int(offset_x * math.cos(angle) - offset_y * math.sin(angle))
    offset_y_rotated = int(offset_x * math.sin(angle) + offset_y * math.cos(angle))

    rotated_matrix = []

    for y in range(height2):
        row = []
        for x in range(width2):
            # map new (x, y) to original image coordinates
            orig_x = int(x * math.cos(-angle) - (-y) * math.sin(-angle)) - offset_x_rotated
            orig_y = int(x * math.sin(-angle) + (-y) * math.cos(-angle)) + offset_y_rotated
            if 0 <= orig_x < width and 0 <= -orig_y < height:
                row.append(matrix[-orig_y][orig_x]) # switching back to image coords
            else:
                # if original coords are out of bound of original image, set pixel to white
                row.append((255, 255, 255, 0))
        rotated_matrix.append(row)

    return rotated_matrix


def skew_matrix(matrix, x_skew, y_skew):
    height = len(matrix)
    width = len(matrix[0])

    corners = [[0, 0], [width, 0], [width, height], [0, height]]
    transformed_corners = [
        (int(x + y * x_skew), int(y + x * y_skew))
        for (x, y) in corners]
    xs = [pt[0] for pt in transformed_corners]
    ys = [pt[1] for pt in transformed_corners]

    height2 = int(max(ys) - min(ys))
    width2 = int(max(xs) - min(xs))

    offset_x = int(min(xs))
    offset_y = int(min(ys))

    skewed_matrix = [[(255, 255, 255, 0) for _ in range(width2)] for _ in range(height2)]

    for y in range(height):
        for x in range(width):
            # map original image (x, y) to new coordinates
            x2 = int(x + y * x_skew - offset_x)
            y2 = int(y + x * y_skew - offset_y)
            if 0 <= x2 < width2 and 0 <= y2 < height2:
                skewed_matrix[y2][x2] = matrix[y][x]

    return skewed_matrix


def scale_matrix(matrix, x_scale, y_scale):
    height = len(matrix)
    width = len(matrix[0])

    height2 = int(height * y_scale)
    width2 = int(width * x_scale)

    scaled_matrix = []

    for y in range(height2):
        row = []
        for x in range(width2):
            # map new (x, y) to original image coordinates
            orig_x = int(x / x_scale)
            orig_y = int(y / y_scale)

            row.append(matrix[orig_y][orig_x])

        scaled_matrix.append(row)

    return scaled_matrix


# ================

img = Image.open("cody.png")

img.show()

img_matrix = image_to_matrix(img)
#img_matrix2 = matrix_transpose(img_matrix)
#img_matrix2 = rotate_matrix(img_matrix, 45)
img_matrix2 = skew_matrix(img_matrix, -0.4, -0.4)
#img_matrix2 = scale_matrix(img_matrix, 10, 10)

img2 = matrix_to_image(img_matrix2)

img2.show()





